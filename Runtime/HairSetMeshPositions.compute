#pragma kernel Main

//----------
// includes

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl"

#include "HairVertex.hlsl"

ByteAddressBuffer   _VertexBufferUV;
RWByteAddressBuffer _VertexBuffer;

[numthreads(1024, 1, 1)]
void Main(uint3 dispatchID : SV_DispatchThreadID)
{
    // We need to manually handle the UNORM since we are in a compute shader. 
    float4 normalizedPackedID;
    {
    #if 1
        uint packedValue = _VertexBufferUV.Load(dispatchID.x << 2);
        
        normalizedPackedID = float4
        (
            ((packedValue >>  0) & 0xFF) / 255.0,
            ((packedValue >>  8) & 0xFF) / 255.0,
            ((packedValue >> 16) & 0xFF) / 255.0,
            ((packedValue >> 24) & 0xFF) / 255.0
        );
    #else
        // TODO: Handle the UNORM16 Case.
    #endif
    }
    
    const HairVertex v = GetHairVertex(normalizedPackedID, 0, 0, 0, 0);
    {
        // temp hack: un-do some translations
        const float3 x = TransformObjectToWorld(v.positionOS);
        const float3 y = GetAbsolutePositionWS(x);
        const float3 z = TransformWorldToObject(y);

        // todo: the stride + offset should probably not be hard coded
        _VertexBuffer.Store3((40u * dispatchID.x) + 0u,  asuint(z));
        _VertexBuffer.Store3((40u * dispatchID.x) + 12u, asuint(v.normalOS));
        _VertexBuffer.Store4((40u * dispatchID.x) + 24u, asuint(float4(v.tangentOS, 1.0)));
    }
}