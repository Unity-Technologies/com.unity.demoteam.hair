#pragma kernel Main

#pragma multi_compile __ STAGING_COMPRESSION
// 0 == staging data full precision
// 1 == staging data compressed

#pragma multi_compile __ HAIR_VERTEX_ID_LINES HAIR_VERTEX_ID_STRIPS HAIR_VERTEX_ID_TUBES
// *_LINES == render as line segments
// *_STRIPS == render as view facing strips

#pragma multi_compile HAIR_VERTEX_SRC_SOLVER HAIR_VERTEX_SRC_STAGING
// *_SOLVER == source vertex from solver data
// *_STAGING == source vertex data from staging data

//----------
// includes

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.shadergraph/ShaderGraphLibrary/ShaderVariablesFunctions.hlsl"

#include "HairVertex.hlsl"

RWByteAddressBuffer _VertexBuffer;
ByteAddressBuffer   _VertexBufferUV;

float2 LoadVertexUV(uint vertexID)
{
    uint  uv = _VertexBufferUV.Load(vertexID << 2);
    float lo = UnpackUIntToFloat(uv, 0u,  16u);
    float hi = UnpackUIntToFloat(uv, 16u, 16u);
    return float2(lo, hi);
}

[numthreads(1024, 1, 1)]
void Main(uint3 dispatchID : SV_DispatchThreadID)
{
    const uint   vertexID = dispatchID.x;
    const float2 vertexUV = LoadVertexUV(vertexID);

    const HairVertex v = GetHairVertex(vertexID, vertexUV, 0, 0, 0);
    {
        // temp hack: un-do some translations
        const float3 x = TransformObjectToWorld(v.positionOS);
        const float3 y = GetAbsolutePositionWS(x);
        const float3 z = TransformWorldToObject(y);

        // todo: the stride + offset should probably not be hard coded
        _VertexBuffer.Store3((40u * vertexID) + 0u,  asuint(z));
        _VertexBuffer.Store3((40u * vertexID) + 12u, asuint(v.normalOS));
        _VertexBuffer.Store4((40u * vertexID) + 24u, asuint(float4(v.tangentOS, 1.0)));
    }
}